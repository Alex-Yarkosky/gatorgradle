plugins {
    id "maven"
    id "java-gradle-plugin"
    id "com.gradle.plugin-publish" version "0.9.7"
    id "ru.vyarus.quality" version "2.4.0"
}

ext.gitVersioner = [
        /* defaultBranch           : "master",  // default "master" */
        stableBranches          : ["master"], // the feature branch postfix (-dm4(6)) will not be appended on stable branches
        yearFactor              : 500, 	  // default "1000", increasing every 8.57h
        snapshotEnabled         : false,      // default false, the "-SNAPSHOT" postfix
        localChangesCountEnabled: false,       // default false, the (<commitCount>) before -SNAPSHOT
]
// import the script which runs the version generation
apply from: "versioner.gradle"

group = "${artifact_group}"
def sem_version = "${artifact_release}.${artifact_patch}"
version = "${sem_version}-${gitVersionName}"

println("\u001B[1;36mVERSION ${version}\u001B[0m")

pluginBundle {
    website = "http://github.com/gatored/gatorgradle"
    vcsUrl = "https://github.com/gatored/gatorgradle"
    description = "Gradle plugin for integrating the grading tool GatorGrader as a runnable, configurable task"
    tags = ["grading", "allegheny", "gatorgrader", "mdl", "proselint"]

    plugins {
        gatorgradle {
            id = "${artifact_name}"
            description = "Integrates GatorGrader checking as a task, as used at Allegheny College."
            displayName = "GatorGradle"
      }
  }
}

gradlePlugin {
    plugins {
        gatorgradle {
            id = "${artifact_name}"
            implementationClass = "org.gatorgradle.GatorGradlePlugin"
        }
    }
}

uploadArchives {
    repositories {
        mavenDeployer {
            repository(url: "file://${System.properties['user.home']}/.m2/repository")
        }
    }
}

def getBranch() {
    def branch = ""
    def proc = "git rev-parse --abbrev-ref HEAD".execute()
    proc.in.eachLine { line -> branch = line }
    proc.err.eachLine { line -> println line }
    proc.waitFor()
    return branch
}

def executeCommand(String command, String error, boolean sendToConsole=true, String errorCommand=null) {
    def err = false

    // parse into list to accomodate spaces and quoted strings

    def cmd = []
    act.split("\"").each {
        if(it.trim() != "") { cmd += it.trim() }
    }

    def proc = cmd.execute()
    if(sendToConsole) {
        proc.in.eachLine { line -> println line }
    }
    proc.err.eachLine { line ->
        println line
        err = true
    }

    proc.waitFor()
    if(proc.exitValue() != 0) {
        if(errorCommand != null) {
            executeCommand(errorCommand, "Unknown nested error, see above!", null, true)
        }
        throw new GradleException("${error}")
    } else if (err) {
        throw new GradleException("Unknown error, see above!")
    }
}

def checkLocalChanges() {

    executeCommand("git update-index -q --ignore-submodules --refresh", "Failed to update git index")
    executeCommand("git diff-files --quiet --ignore-submodules", "Please commit your changes!");
    executeCommand("git diff-index --cached --quiet HEAD --ignore-submodules", "Please add your changes:", true, "git diff-index --cached --name-status -r --ignore-submodules HEAD")
}

def switchToBranch(String branch) {
    checkLocalChanges()
    def err = false
    def proc = "git checkout ${branch}".execute()
    proc.waitFor()
    if(getBranch() != branch) {
        err = true
        println "Git didn't switch to " + getBranch()
    }

    if(err) {
        throw new GradleException("Could not checkout ${branch}!")
    }
}



def copy(String from, String to) {
    def srcStream = new File(from).newDataInputStream()
    def dstStream = new File(to).newDataOutputStream()
    dstStream << srcStream
    srcStream.close()
    dstStream.close()
}

def createJavadocBadge(String status, String dest) {
    def filename = "docs-${status.toLowerCase()}.svg"
    println filename
    copy("images/${filename}", dest)
}

def publishToGit(String path, String branch=null) {
    def currBranch = getBranch()
    def switched = false
    if(branch != null && branch != currBranch) {
        switchToBranch(branch)
        switched = true
    } else {
        branch = currBranch
    }
    executeCommand("git add ${path}", "Failed to add ${path} to git!", true)
    executeCommand("git commit -m \"automatic javadoc publish for v${version}\"", "Failed to commit ${path} to git!", true)
    executeCommand("git push -u origin ${branch}", "Failed to push to git!", true)

    if(switched) {
        switchToBranch(currBranch)
    }

}

def addVersionToDatalist(String docFolder, String versionsFile) {

    def currBranch = getBranch()
    def switched = false
    if(currBranch != "gh-pages") {
        switchToBranch("gh-pages")
        switched = true
    }

    def date = new Date().format("MMMM d, YYYY", TimeZone.getTimeZone("UTC"))
    def (semantic, build) = version.split("-")

    def file = new File(versionsFile)

    file << "\"" << build << "\",\"" << semantic << "\",\"" << date << "\",\"" << docFolder << "\""

    if(switched) {
        switchToBranch(currBranch)
    }

}

task publishJavadocs(type: GradleBuild) {
    def docFolder = "docs/${sem_version}"
    project.tasks.findByName("javadoc").destinationDir = file(docFolder)

    tasks = ['clean', 'javadoc']

    doLast {
        def oldBranch = ""
        println("running javadoc")
        oldBranch = getBranch()
        switchToBranch("gh-pages")
        println "switched branch to ${getBranch()}"

        // TODO: determine this better
        def status = "passing"
        def badge = "docs/docs-status-badge.svg"
        def versionsFile = "_data/versions.csv"

        createJavadocBadge(status, badge)
        addVersionToDatalist(docFolder, versionsFile)
        publishToGit(docFolder + " " + badge, "gh-pages")
        println "on branch ${getBranch()}"
        switchToBranch(oldBranch)
        println "switched branch to ${getBranch()}"
    }
}

quality {
    checkstyleVersion = "8.1"

    // disable PMD for now (100+ issues to fix)
    pmd = false;

    findbugsLevel = "low"
}

dependencies {
    compile gradleApi()
}

repositories {
    mavenLocal()
    jcenter()
    mavenCentral()
}

/* tasks.whenTaskAdded { task ->
    if (task.getName().contains("PluginMavenPublication")) {
        task.setDependsOn([])
        task.setMustRunAfter([])
        task.setShouldRunAfter([])
        task.setEnabled(false)
    }
} */

sourceCompatibility = 1.8
targetCompatibility = 1.8
